<blockquote style="font-size:12px">
    <p>A good architecture allows you to defer framework decisions.  A good architecture allows frameworks to act as plugins to the app.</p>
    <p><cite>Uncle Bob Martin</cite></p>
</blockquote>

<h3>EO - Elastic Objects</h3>

<p>
Service oriented architecture today is usually some typed RPC calls bound to urls by
    an application server framework. <b>Type</b> and <b>functionality</b> mapping is stuck
    in a procedural concept
    from the IT stone age and fat web application frameworks.
</p>

<p>With GraphQL a service approach with a generic end point emerges. A client is free to
    combine configurable request message to the service.
    The message is a special GraphQL format returning
    a JSON result. Schema informations have to be defined as well as the binding to some
    server functionality.
</p>
<h5>Service Concept</h5>
<p>
    The concept of Elastic Objects uses a <b>"typed" JSON</b> for messages to instantiate pojos in
    an arbitrary object hierarchy context. A special <b>"call" pojo</b> with a generic execute method offers
    any functionality.
</p>
<img src="/pics/eoCall.svg" width="200" style="margin:20px;"/>
<p>These calls uses
<ul>
    <li> ==>{ConfigLinkCall->FieldConfig, sourcePath}. for the location of the input</li>
    <li> ==>{ConfigLinkCall->FieldConfig, targetPath}. for storing the output</li>
</ul>
The returned message is the same as the incoming but "enriched" by the executed calls. The architecture is
like a <b>shopping bag</b>, where the calls are the <b>shopping list items</b>.
</p>


==>{TemplateDirResourceCall->examples, SinusValueCall.html}.

<h5>Simple Calls</h5>
<p>
    The implementation of a simple call is just straight forward. To offer it's functionality
    to a service only an entry in the
    ==>{GithubLinkCall->NONE, SPR||ModelConfig.json}. is necessary.
</p>
<p>
    As examples you find here
    ==>{ConfigLinkCall->ModelConfig, TheGreetingCall}. or more senseful the links used for this
    website on ==>{ConfigLinkCall->ModelConfig, ConfigLinkCall}..
</p>

==>{TemplateDirResourceCall->examples, FileReadCall.html}.


<h5>File Resources</h5>
<p>The ==>{ConfigLinkCall->ModelConfig, FileReadCall}. example uses
    ==>{ConfigLinkCall->ModelConfig, ResourceCall}..
</p>
<p>
    To allow access to a file resource on the server one just has to add an entry in
    ==>{GithubLinkCall->NONE, SPR||FileConfig.json}. in the classpath.
</p>
<p>Every offered file based resource call has an entry here. So you find in |
    ==>{GithubLinkCall->NONE, SPR||FileConfig.json#L2}. one to read
    some Excel sheet.
</p>


==>{TemplateDirResourceCall->examples, XlsxReadCall.html}.


==>{TemplateDirResourceCall->examples, TemplateResourceCall.html}.


==>{TemplateDirResourceCall->examples, TemplateCall.html}.


<h5>Conclusion</h5>
<p>
With a simple tiny typed JSON extension
    one could build incredible flexible service architectures with a more object oriented approach.
</p>
<p>
    I think that EO is a nice "Proof of Concept" in Java. To make a framework
    I could waste endless time to check out
    all possibilities, not mentioned other programming languages.
</p>

<p>
    So I will put mor focus on the original
    intention: The generation of code in
    ==>{GithubLinkCall->NONE, B||Builder.java}.. by structured data like
    ==>{GithubLinkCall->NONE, BR||eo.xlsx}. .
</p>

<p>I hope the examples show what is practicable possible
    with a minimal standard extensions.
I would love to work with a framework with such a concept.
</p>

<p>
    But it's the opposite of Uncle Bob Martins quote at the beginning.
    The framework configuration build the heart of the app
    to eliminate differences in
programming languages, application servers and frameworks.
</p>
<p>
    So it could inject type binding to untyped languages and improve types even to Java e.g. with length.
</p>