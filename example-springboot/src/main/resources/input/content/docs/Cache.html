<p>The CacheProvider object plays the central role for caching the deserialized configurations. A cached configuration
    is usually find by the combination CacheClass + filterKey.</p>
<p>The CacheProvider only loads the
    <a href="model">Models</a> when initialized,
    <a href="call">Actions</a> are loaded <em>lazy</em> on demand.
    When a certain config class is called the first time, a new Provider for this config class is created which will be
    initialized reading all [CacheClass].json file names in the classpath.
</p>
<p>Each CacheClass has a bean for deserializing the json files via Jackson in the class path with a build method
    creating the config class. With this approach the config fields could be <em>final</em>.</p>
<p>Since the CacheProvider is a simple object, it could be integrated in different application frameworks like
    Spring. </p>
<p><a name="example"/></p>
<h4>Spring Configuration</h4>
<p>In the example application the config is integrated in Spring via the following configuration: </p>
<pre>
@Configuration
public class ElasticObjectsConfiguration {
@Value("${elasticobjects.scope:QS}")
  String scope;

  @Bean
  public ProviderCache createProvider() {
    return new ProviderCache(Scope.valueOf(scope));
  }
}</pre>
<p>It could be used defining a <a href="adapter#example">web service interface</a>. </p>
<h4>Generation</h4>
<p>It&#8217;s easy to loose track with the distributed JSON configurations. These configurations could be rather huge so
    they should be generated itself by a more user friendly input tool. </p>
<p>For the beginning I use some Excel in the builder module e.g. for <a
        href="http://fluentcodes.com/wp-content/uploads/2018/02/models.xlsx">models</a>.</p>
<h4>Cache Web Interface</h4>
<p>Since all models/actions are stored in the EOConfigs one can define an interface to deliver the EOConfigs information
    via web interface to a client application.</p>';
